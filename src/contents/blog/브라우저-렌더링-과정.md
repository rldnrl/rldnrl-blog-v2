---
title: 브라우저 렌더링 과정
date: '2021-9-28'
tags: ['browser']
draft: false
summary: 나는 프론트엔드 개발을 하고 있다. 그러나 브라우저에 대한 이해가 별로 없었다. 사실 궁금하지도 않았다. 하지만 언제가는 필요한 순간이 온다. 그 순간을 위해서 정리를 해봤다.
---

나는 프론트엔드 개발을 하고 있다. 그러나 브라우저에 대한 이해가 별로 없었다. 사실 궁금하지도 않았다. 하지만 개발하다보면 언제가는 필요한 순간이 온다. 그 순간을 위해서 정리를 해봤다.

## Browser의 흐름

1. 사용자 인터페이스에서 유저가 URI를 입력하여 브라우저 엔진에 전달한다.
2. 브라우저 엔진에서 URI에 대해 쿠키로 저장한 자료가 있으면 자료 저장소에서 가져온다.
3. 렌더링 엔진은 브라우저 엔진에서 가져온 쿠키 값과 URI 데이터를 통신, 자바스크립트 해석기, UI 백엔드 로 전파한다.
4. 통신 레이어에 URI에 대해 데이터를 요청하고 응답할 때까지 기다린다.
5. 요청받은 데이터에서 JavaScript는 JavaScript 해석기에서 분석하여 렌더링 엔진에서 HTML CSS와 함께 분석한다.
6. 브라우저 렌더링 화면에 띄워준다.

## 구성 요소 및 역할

1. **사용자 인터페이스**: 주소 표시 줄, 이전/다음 버튼, 홈버튼, 새로 고침/정지 버튼 등 요청한 페이지를 보여주는 창 외의 사용자가 컨트롤 할 수 있는 부분을 일컫는다.
2. **브라우저 엔진**: 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어한다.
3. **렌더링 엔진**: 요청한 URI를 브라우저에서 받아 콘텐츠를 표시해준다. HTML을 요청하면 HTML과 CSS를 파싱하여 창에 보여준다.
4. **통신**: HTTP 요청과 같은 네트워크 처리를 담당하는 부분, 이 부분은 독립적인 인터페이스라 각 플랫폼의 하부에서 (OS) 실행된다.
5. **자바스크립트 해석기**: 자바스크립트를 해석하여 실행해주는 부분
6. **UI 백엔드**: 렌더링 엔진이 브라우저에 페이지를 Rendering 할 때 Render Tree로 구성된 노드를 가로지르며 그려주는 역할을 한다.
7. **자료 저장소**: 이 부분은 자료를 저장하는 계층이다. 쿠키 등의 자료가 들어가 있으며, 자료는 컴퓨터의 하드디스크에 저장된다. HTML5에서는 더 쉽게 사용할 수 있도록 웹 데이터베이스를 사용할 수 있도록 지원한다.

## 렌더링 엔진

렌더링 엔진의 역할은 요청 받은 내용을 브라우저 화면에 표시하는 일이다.

렌더링 엔진은 HTML 및 XML 문서와 이미지를 표시할 수 있다. 물론 플러그인이나 브라우저 확장 기능을 이용해 PDF와 같은 다른 유형도 표시할 수 있다. 그러나 이 장에서는 HTML과 이미지를 CSS로 표시하는 주된 사용 패턴에 초점을 맞출 것이다.

렌더링 엔진에는 Gecko와 Webkit이 있다.

## 동작 과정

렌더링 엔진은 통신으로부터 요청한 문서의 내용을 얻는 것으로 시작하는데 문서의 내용은 보통 8KB 단위로 전송된다.

다음은 렌더링 엔진의 기본적인 동작 과정이다.

<img src="/static/images/browser/browser_rendering_process.jpg" />

1. DOM 트리 구축을 위한 HTML 파싱
   HTML 문서를 받아서 파싱하고 컨텐츠 트리 내부에서 태그(a, div)를 DOM(Document Object Map) 노드로 변환한다. 그 다음 CSS 파일과 함께 포함된 스타일 요소를 파싱한다. 스타일 정보와 HTML 표시 규칙들은 Render Tree라고 부르는 또 다른 트리를 생성한다.

2. 렌더 트리 구축
   HTML과 CSS를 파싱해서 만들어진 렌더 트리는 색상 또는 면적 등의 시각적 속성을 갖고 있는 사각형을 포함하고 있다. 정해진 순서대로 렌더링하게 된다.

3. 렌더 트리 배치
   렌더 트리 구축이 끝나면 배치가 시작된다. 각 노드가 정확한 위치에 표시되기 위해 이동한다.

4. 렌더 트리 그리기
   배치를 완료하면 UI 백앤드에서 각 노드를 가로지르며 Paint 작업을 한다.

   일련의 과정들이 점진적으로 진행된다는 것을 아는 것이 중요하다. 렌더링 엔진은 좀 더 나은 사용자 경험을 위해 가능하면 빠르게 내용을 표시하는데 모든 HTML을 파싱할 때까지 기다리지 않고 배치와 그리기 과정을 시작한다. 네트워크로부터 나머지 내용이 전송되기를 기다리는 동시에 받은 내용의 일부를 먼저 화면에 표시하는 것이다.

<br />

## DOM이란?

DOM (Document Object Model)은 JavaScript로 HTML문서의 구조에 접근해서 변경하거나 추가하는 작업을 가능하게 하는 HTML 문서를 파싱하여 만든 Tree 형태의 Model을 말한다.

## DOM 생성 원리

HTML을 JavaScript에서 컨트롤 및 그려줄 수 있게 Render Tree를 구축하려면, DOM을 만들어야한다.

DOM은 객체를 Node로 만들어서 Tree 형태로 만들어야 한다. 여기서 쓰이는 파서는 문맥 자유 문법(HTML이므로)이 아니기 때문에 브라우저 별 구현이 되어있다. 하지만 브라우저 별 전혀 다른 방법으로 구현이 되어 있지는 않다. 어느정도 W3C에서 제정한 가이드라인을 따른다.

DOM은 아래와 같은 과정을 거친다.

<img src="/static/images/browser/DOM_Tree.jpg" />

1. 변환: 브라우저가 HTML의 원시 바이트를 디스크나 네트워크에서 읽어와서, 해당 파일에 대해 지정된 인코딩(예: UTF-8)에 따라 개별 문자로 변환한다.
2. 토큰화: 브라우저가 문자열을 W3C HTML5 표준에 지정된 고유 토큰으로 변환한다. 각 토큰은 특별의미와 고유한 규칙을 가진다.
3. 렉싱: 변환된 토큰은 해당 속성 및 규칙을 정의하는 '객체'로 변환된다.
4. DOM 링크: 마지막으로, HTML 마크업이 여러 태그(일부 태그는 다른 태그 안에 포함되어 있음) 간의 관계를 정의하기 때문에 생성된 객체는 트리 데이터 구조 내에 연결된다. 이 트리 데이터 구조에는 원래 마크업에 정의된 상위-하위 관계도 포함된다. 즉, HTML 객체는 body 객체의 상위이고, body 는 paragraph 객체의 상위인 식이다.

<img src="/static/images/browser/DOM_Tree_Completed.jpg" />

<br />

## CSSOM(CSS Object Model)

브라우저는 단순한 페이지의 DOM을 생성하는 동안 외부 CSS 스타일시트인 style.css를 참조하는 문서의 헤드 섹션에서 링크 태그를 접한다. 페이지를 렌더링하는 데 이 리소스가 필요할 것이라고 판단한 브라우저는 이 리소스에 대한 요청을 즉시 발송하고 요청의 결과로 다음 콘텐츠가 반환된다.

```css
body {
  font-size: 16px;
}
p {
  font-weight: bold;
}
span {
  color: red;
}
p span {
  display: none;
}
img {
  float: right;
}
```

HTML과 마찬가지로, 수신된 CSS 규칙을 브라우저가 이해하고 처리할 수 있는 형식으로 변환해야 한다. 따라서 HTML 대신 CSS에 대해 HTML 프로세스를 반복한다.

<img src="/static/images/browser/CSSOM_Process.jpg" />

CSS 바이트가 문자로 변환된 후 차례로 토큰과 노드로 변환되고 마지막으로 'CSS Object Model'(CSSOM)이라는 트리 구조에 링크된다.

<img src="/static/images/browser/CSSOM_Tree.jpg" />

### CSSOM이 트리 구조를 가지고 있는 이유

페이지에 있는 객체의 최종 스타일을 계산할 때 브라우저는 해당 노드에 적용 가능한 가장 일반적인 규칙(예: body 요소의 하위인 경우 모든 body 스타일 적용)으로 시작한 후 더욱 구체적인 규칙을 적용하는 방식으로, 즉 '하향식'으로 규칙을 적용하는 방식으로 계산된 스타일을 재귀적으로 세분화한다.

더욱 구체화하기 위해 위에 나와 있는 CSSOM 트리를 살펴보자. body 요소 내에 있는 span 태그 안에 포함된 모든 텍스트의 글꼴 크기는 16px이고 색상은 빨간색이다. font-size 지시문은 body에서 span으로 하향식으로 적용되기 때문이다. 하지만 span 태그가 단락(p) 태그의 하위인 경우 해당 콘텐츠는 표시되지 않는다.

또한, 위의 트리는 완전한 CSSOM 트리가 아니고 스타일시트에서 재정의하도록 결정한 스타일만 표시한다는 점에 유의하자. 모든 브라우저는 '사용자 에이전트 스타일'이라고 하는 기본 스타일 집합, 즉 개발자가 고유한 스타일을 제공하지 않을 경우 표시되는 스타일을 제공한다. 개발자가 작성하는 스타일은 이러한 기본 스타일을 간단하게 재정의한다.

<br />

## 렌더 트리

렌더링 엔진에서 DOM(Document Object Model)과 CSSOM(CSS Object Model)을 생성한 후, Attachment 과정을 통해 Render Tree를 만들게 된다.

이 Render Tree는 각 요소의 레이아웃을 계산하는데 사용되며, 픽셀을 화면에 렌더링하는 페인트 프로세스에 대한 입력으로 처리 된다. 그러므로 최적화를 하려면 DOM(Document Object Model)과 CSSOM(CSS Object Model) 작업을 할 때 각각 최적화를 해주는 일이 매우 중요하다.

- DOM과 CSSOM 트리는 결합되어 렌더링 트리를 생성한다.
- 렌더링 트리에는 페이지를 렌더링하는데 필요한 노드만 포함되어 있다.
- 레이아웃은 각 객체의 정확한 위치 및 크기를 계산한다.
- 마지막 단계는 최종 렌더링 트리에서 수행되는 페인트이다. 픽셀을 화면에 렌더링 한다.

<img src="/static/images/browser/render_tree.jpg" />

렌더링 트리를 생성하려면 브라우저가 대략적으로 다음 작업을 수행한다.

1. DOM 트리의 루트에서 시작하여 표시되는 노드 각각을 트래버스 한다.

- 일부 노드는 표시되지 않으며(예: 스크립트 태그, 메타 태그 등), 렌더링된 출력에 반영되지 않으므로 생략된다.
- 일부 노드는 CSS를 통해 숨겨지며 렌더링 트리에서도 생략된다. 예를 들어, `display: none` 속성을 설정하는 명시적 규칙이 있다면, 렌더링 트리에서 누락된다.

2. 표시된 각 노드에 대해 적절하게 일치하는 CSSOM 규칙을 찾아 적용한다.
3. 표시된 노드를 콘텐츠 및 계산된 스타일과 함께 내보낸다.

### `visibility: hidden` vs `display: none`

`visibility: hidden`: 요소를 보이지 않게 만들지만, 이 요소는 여전히 레이아웃에서 공간을 차지한다. 즉, 비어 있는 상자로 렌더링된다.

`display: none`: 요소가 보이지 않으며 레이아웃에 포함되지도 않도록 렌더링 트리에서 요소를 완전히 제거된다.

최종 출력은 화면에 표시되는 모든 노드의 콘텐츠 및 스타일 정보를 모두 포함하는 렌더링 트리이다. 렌더링 트리가 생성되었으므로 **"레이아웃"** 단계로 진행할 수 있다.

<br />

## 레이아웃

기기의 뷰포트 내에서 이러한 노드의 정확한 위치와 크기를 계산한다. 이것을 **"레이아웃"** 또는 경우에 따라서 **"리플로우"** 라고 한다.

```html
<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Critial Path: Hello world!</title>
  </head>
  <body>
    <div style="width: 50%">
      <div style="width: 50%">Hello world!</div>
    </div>
  </body>
</html>
```

위 페이지의 본문에는 두 가지 중첩된 `div`가 포함되어 있다. 첫 번째(상위) `div`는 노드의 표시 크기를 뷰포트 너비의 50%로 설정하며, 상위 `div`에 포함된 두 번째 `div`는 해당 너비를 상위 항목 너비의 50%(즉, 뷰포트 너비의 25%)로 설정한다.

<img src="/static/images/browser/layout.jpg" />

레이아웃 프로세스에서는 뷰포트 내에서 각 요소의 정확한 위치와 크기를 정확하게 캡처하는 **'box model'** 이 출력된다. 모든 상대적인 측정값은 화면에서 절대적인 픽셀로 변환된다.

마지막으로, 이제 표시되는 노드와 해당 노드의 계산된 스타일 및 기하학적 형태에 대해 파악했으므로, 렌더링 트리의 각 노드를 화면의 실제 픽셀로 변환하는 마지막 단계로 이러한 정보를 전달할 수 있다. 이 단계를 흔히 **'페인팅'** 또는 **'래스터화'** 라고 한다.

이 경우 브라우저가 처리해야 할 작업이 상당히 많으므로 시간이 약간 걸릴 수 있다.

렌더링 트리 생성, 레이아웃 및 페인트 작업을 수행하는 데 필요한 시간은 문서의 크기, 적용된 스타일 및 실행 중인 기기에 따라 달라진다. 즉, 문서가 클수록 브라우저가 수행해야 하는 작업도 더 많아지며, 스타일이 복잡할수록 페인팅에 걸리는 시간도 늘어난다. 예를 들어, 단색은 페인트하는 데 시간과 작업이 적게 필요한 반면, 그림자 효과는 계산하고 렌더링하는 데 시간과 작업이 더 필요하다.
